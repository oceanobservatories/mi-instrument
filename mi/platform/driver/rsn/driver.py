#!/usr/bin/env python

"""
@package ion.agents.platform.rsn.rsn_platform_driver
@file    ion/agents/platform/rsn/rsn_platform_driver.py
@author  Carlos Rueda
@brief   The main RSN OMS platform driver class.
"""

__author__ = 'Carlos Rueda'
__license__ = 'Apache 2.0'


from pyon.public import log, CFG
from pyon.core.exception import BadRequest
import logging

from copy import deepcopy

from mi.platform.platform_driver import PlatformDriver
from mi.platform.platform_driver import PlatformDriverState
from mi.platform.platform_driver import PlatformDriverEvent
from mi.platform.platform_driver_event import ExternalEventDriverEvent
from mi.platform.exceptions import PlatformException
from mi.platform.exceptions import PlatformDriverException
from mi.platform.exceptions import PlatformConnectionException
from mi.platform.driver.rsn.oms_client_factory import CIOMSClientFactory
from mi.platform.responses import InvalidResponse

from ion.agents.platform.util import ion_ts_2_ntp

from pyon.agent.common import BaseEnum
from pyon.agent.instrument_fsm import FSMError

from pyon.core.object import ion_serializer, IonObjectDeserializer
from pyon.core.registry import IonObjectRegistry
from ion.core.ooiref import OOIReferenceDesignator

class RSNPlatformDriverState(PlatformDriverState):
    """
    We simply inherit the states from the superclass
    """
    pass


class RSNPlatformDriverEvent(PlatformDriverEvent):
    """
    The ones for superclass plus a few others for the CONNECTED state.
    """
    TURN_ON_PORT              = 'RSN_PLATFORM_DRIVER_TURN_ON_PORT'
    TURN_OFF_PORT             = 'RSN_PLATFORM_DRIVER_TURN_OFF_PORT'
    SET_OVER_CURRENT          = 'RSN_PLATFORM_DRIVER_SET_OVER_CURRENT'


class RSNPlatformDriverCapability(BaseEnum):
    TURN_ON_PORT              = RSNPlatformDriverEvent.TURN_ON_PORT
    TURN_OFF_PORT             = RSNPlatformDriverEvent.TURN_OFF_PORT
    SET_OVER_CURRENT          = RSNPlatformDriverEvent.SET_OVER_CURRENT


class PlatformDriver(PlatformDriver):
    """
    The main RSN OMS platform driver class.
    """

    def __init__(self, pnode, event_callback,
                 create_event_subscriber, destroy_event_subscriber):
        """
        Creates an RSNPlatformDriver instance.

        @param pnode           Root PlatformNode defining the platform network
                               rooted at this platform.
        @param event_callback  Listener of events generated by this driver

        @param create_event_subscriber
        @param destroy_event_subscriber
        """
        PlatformDriver.__init__(self, pnode, event_callback,
                                create_event_subscriber, destroy_event_subscriber)

        # CIOMSClient instance created by connect() and destroyed by disconnect():
        self._rsn_oms = None

        # TODO(OOIION-1495) review the following. Commented out for the moment.
        # What does "ports that have devices attached" mean?
        """
        # Simple list of active ports in this deployment configuration:
        # (this should be all the ports that have devices attached. Used in go_active processing
        self._active_ports = []
        """

        self._instr_port_map = {}

        # URL for the event listener registration/unregistration (based on
        # web server launched by ServiceGatewayService, since that's the
        # service in charge of receiving/relaying the OMS events).
        # NOTE: (as proposed long ago), this kind of functionality should
        # actually be provided by some component more in charge of the RSN
        # platform netwokr as a whole -- as opposed to platform-specific).
        self.listener_url = None

        # external event listener: created in _start_event_dispatch
        self._event_listener = None

    def get_platform_driver_event_class(self):
        return RSNPlatformDriverEvent

    def get_platform_driver_capability_class(self):
        return RSNPlatformDriverCapability

    def validate_driver_configuration(self, driver_config):
        """
        Driver config must include 'oms_uri' entry.
        """
        if not 'oms_uri' in driver_config:
            msg = "%r: 'oms_uri' not present in driver_config = %s" % (
                  self._platform_id, driver_config)
            log.error(msg)
            raise PlatformDriverException(msg=msg)

        # validate and process ports
        if not 'ports' in driver_config:
            msg = "%r: 'ports' not present in driver_config = %s" % (
                self._platform_id, driver_config)
            log.error(msg)
            raise PlatformDriverException(msg=msg)

        self._instr_port_map = {}
        ports = driver_config['ports']
        for port_id, port_attrs in ports.iteritems():
            if 'instruments' not in port_attrs:
                continue
            instruments = port_attrs['instruments']
            for instr_id, instr_attrs in instruments.iteritems():
                if instr_id in self._instr_port_map:
                    msg = "%r: instrument=%r already associated with port=%r" % (
                        self._platform_id, instr_id, port_id)
                    log.error(msg)
                    raise PlatformDriverException(msg=msg)
                self._instr_port_map[instr_id] = port_id
        log.debug("%r: _instr_port_map: %s", self._platform_id, self._instr_port_map)

        # TODO(OOIION-1495) review the following added logic.
        # Per recent discussions there would be two main sources for platform
        # port information: 1- from ongoing deployment; 2- from direct port
        # configuration when no ongoing deployment available.
        """
        # Create an IonObjectDeserializer
        ior = IonObjectRegistry()
        ion_deserializer = IonObjectDeserializer(obj_registry=ior)

        port_info_dict = driver_config['ports']
        for device_id, platform_port_serialized in port_info_dict.iteritems():

            platform_port = ion_deserializer.deserialize(platform_port_serialized)
            ooi_rd = OOIReferenceDesignator(platform_port.reference_designator)
            if ooi_rd.error or not ooi_rd.port:
                log.error("Invalid port information in driver_config. Reference designator: %s", platform_port.reference_designator)
            else:
                #strip leading zeros from port numbers as OMS stores as strings w/o leading zeros
                port_string = str( int(ooi_rd.port) )
                self._active_ports.append(port_string)
        """
    def configure(self, driver_config):
        """
        Nothing special done here, only calls super.configure(driver_config)

        @param driver_config with required 'oms_uri' entry.
        """
        PlatformDriver.configure(self, driver_config)
        self._construct_resource_schema()

    def _construct_resource_schema(self):
        """
        """
        parameters = deepcopy(self._param_dict)
        ports_dict = self._driver_config.get('ports',{})
        ports = []
        # remove until network checkpoint needs are defined.
        # port info can be retrieve from active deployment
        #for k,v in ports_dict.iteritems():
        #    ports.append(v['port_id'])
        for k,v in parameters.iteritems():
            read_write = v.get('read_write', None)
            if read_write == 'write':
                v['visibility'] = 'READ_WRITE'
            else:
                v['visibility'] = 'READ_ONLY'

        commands = {}
        commands[RSNPlatformDriverEvent.TURN_ON_PORT] = \
            {
                "display_name" : "Port Power On",
                "description" : "Activate port power.",
                "args" : [],
                "kwargs" : {
                       'port_id' : {
                            "required" : True,
                            "type" : "int",
                            "valid_values" : ports
                        }
                }

            }
        commands[RSNPlatformDriverEvent.TURN_OFF_PORT] = \
            {
                "display_name" : "Port Power Off",
                "description" : "Deactivate port power.",
                "args" : [],
                "kwargs" : {
                       'port_id' : {
                            "required" : True,
                            "type" : "int",
                            "valid_values" : ports
                        }
                }
            }
        commands[RSNPlatformDriverEvent.SET_OVER_CURRENT] = \
            {
                "display_name" : "Set over current",
                "description" : "Set over current params to platform port.",
                "args" : [],
                "kwargs" : {
                       'port_id' : {
                            "required" : True,
                            "type" : "int",
                            "valid_values" : ports
                        },
                       'ma' : {
                            "required" : True,
                            "type" : "int"
                        },
                       'us' : {
                            "required" : True,
                            "type" : "int"
                        }
                }
            }
        self._resource_schema['parameters'] = parameters
        self._resource_schema['commands'] = commands

    def ping(self):
        """
        Verifies communication with external platform returning "PONG" if
        this verification completes OK.

        @retval "PONG" iff all OK.
        @raise PlatformConnectionException Cannot ping external platform or
               got unexpected response.
        """
        log.debug("%r: pinging OMS...", self._platform_id)
        try:
            retval = self._rsn_oms.hello.ping()
        except Exception as e:
            raise PlatformConnectionException(msg="Cannot ping: %s" % str(e))

        if retval is None or retval.upper() != "PONG":
            raise PlatformConnectionException(msg="Unexpected ping response: %r" % retval)

        log.debug("%r: ping completed: response: %s", self._platform_id, retval)

        return "PONG"

    def connect(self, recursion=None):
        """
        Creates an CIOMSClient instance, does a ping to verify connection,
        and starts event dispatch.
        """
        # create CIOMSClient:
        oms_uri = self._driver_config['oms_uri']
        log.debug("%r: creating CIOMSClient instance with oms_uri=%r",
                  self._platform_id, oms_uri)
        self._rsn_oms = CIOMSClientFactory.create_instance(oms_uri)
        log.debug("%r: CIOMSClient instance created: %s",
                  self._platform_id, self._rsn_oms)

        # ping to verify connection:
        self.ping()

        # start event dispatch:
        self._start_event_dispatch()

        # TODO(OOIION-1495) review the following. Commented out for the moment.
        # 2014-06-05: The pending review in terms of ports is still relevant in
        # what follows from the original comment here, but note that the
        # Connect_instrument and disConnect_instrument operations have been
        # removed from the CI-OMS interface.
        # Note, per the CI-OMS spec ports need to be turned OFF to then proceed
        # with connecting instruments. So we need to determine whether we
        # want to turn all ports ON in this "connect driver" operation,
        # and then add the logic to turn a port OFF before connecting
        # instruments, and then ON again; or, just do the OFF/ON logic in the
        # Connect_instrument and disConnect_instrument operations,
        # but not here.
        """
        # power all ports with connected devices
        if recursion:
            for port in self._active_ports:
                log.debug('connect power port: %s', port)
                self.turn_on_port(port)
        """

    def disconnect(self, recursion=None):
        """
        Stops event dispatch and destroys the CIOMSClient instance.
        """
        self._stop_event_dispatch()

        # TODO(OOIION-1495) review the following. Only change is the use
        # of self._pnode.ports instead of self._active_ports,
        # while we address the "active ports" concept mentioned above.
        # BTW, is it OK to turn off ports in this "disconnect driver" operation?

        # power off all ports with connected devices
        if recursion:
            for port in self._pnode.ports:
                log.debug('disconnect power port: %s', port)
                self.turn_off_port(port)

        CIOMSClientFactory.destroy_instance(self._rsn_oms)
        self._rsn_oms = None
        log.debug("%r: CIOMSClient instance destroyed", self._platform_id)

    def get_metadata(self):
        """
        """
        try:
            retval = self._rsn_oms.config.get_platform_metadata(self._platform_id)
        except Exception as e:
            raise PlatformConnectionException(msg="Cannot get_platform_metadata: %s" % str(e))

        log.debug("get_platform_metadata = %s", retval)

        if not self._platform_id in retval:
            raise PlatformException("Unexpected: response does not include "
                                    "requested platform '%s'" % self._platform_id)

        md = retval[self._platform_id]
        return md

    def get_subplatform_ids(self):
        """
        Gets the IDs of my sub-platforms.
        """
        return self._pnode.subplatforms.keys()

    def get_attributes(self):
        attrs = self._driver_config.get('attributes', {})
        log.debug("%r: get_attributes=%s", self._platform_id, attrs)
        return attrs

    def get_attribute_values(self, attrs):
        """
        """
        log.debug("get_attribute_values: attrs=%s", attrs)

        if not isinstance(attrs, (list, tuple)):
            raise PlatformException('get_attribute_values: attrs argument must be a '
                                    'list [(attrName, from_time), ...]. Given: %s', attrs)

        # convert the ION system time from_time to NTP, as this is the time
        # format used by the RSN OMS interface:
        attrs_ntp = [(attr_id, ion_ts_2_ntp(from_time))
                     for (attr_id, from_time) in attrs]

        try:
            retval = self._rsn_oms.attr.get_platform_attribute_values(self._platform_id,
                                                                      attrs_ntp)
        except Exception as e:
            raise PlatformConnectionException(msg="Cannot get_platform_attribute_values: %s" % str(e))

        if not self._platform_id in retval:
            raise PlatformException("Unexpected: response does not include "
                                    "requested platform '%s'" % self._platform_id)

        attr_values = retval[self._platform_id]

        # reported timestamps are already in NTP. Just return the dict:
        return attr_values

    def _verify_platform_id_in_response(self, response):
        """
        Verifies the presence of my platform_id in the response.

        @param response Dictionary returned by _rsn_oms

        @retval response[self._platform_id]
        """
        if not self._platform_id in response:
            msg = "unexpected: response does not contain entry for %r" % self._platform_id
            log.error(msg)
            raise PlatformException(msg=msg)

        if response[self._platform_id] == InvalidResponse.PLATFORM_ID:
            msg = "response reports invalid platform_id for %r" % self._platform_id
            log.error(msg)
            raise PlatformException(msg=msg)
        else:
            return response[self._platform_id]

    def _verify_port_id_in_response(self, port_id, dic):
        """
        Verifies the presence of port_id in the dic.

        @param port_id  The ID to verify
        @param dic Dictionary returned by _rsn_oms

        @return dic[port_id]
        """
        if not port_id in dic:
            msg = "unexpected: dic does not contain entry for %r" % port_id
            log.error(msg)
            #raise PlatformException(msg=msg)

        if dic[port_id] == InvalidResponse.PORT_ID:
            msg = "%r: response reports invalid port_id for %r" % (
                                 self._platform_id, port_id)
            log.error(msg)
            #raise PlatformException(msg=msg)
        else:
            return dic[port_id]

    def turn_on_port(self, port_id, src=None):
        """
        Turns on a port.
        @param port_id
                    Port ID
        @param src
                    Some provenance information: actor, mission, etc.
        """
        log.debug("%r: turning on port: port_id=%s src=%s",
                  self._platform_id, port_id, src)

        try:
            response = self._rsn_oms.port.turn_on_platform_port(self._platform_id,
                                                                port_id, src)
        except Exception as e:
            raise PlatformConnectionException(msg="Cannot turn_on_platform_port: %s" % str(e))

        log.debug("%r: turn_on_platform_port response: %s",
                  self._platform_id, response)

        dic_plat = self._verify_platform_id_in_response(response)
        self._verify_port_id_in_response(port_id, dic_plat)

        return dic_plat  # note: return the dic for the platform

    def turn_off_port(self, port_id, src=None):
        """
        Turns off a port.
        @param port_id
                    Port ID
        @param src
                    Some provenance information: actor, mission, etc.
        """
        log.debug("%r: turning off port: port_id=%s src=%s",
                  self._platform_id, port_id, src)

        try:
            response = self._rsn_oms.port.turn_off_platform_port(self._platform_id,
                                                                 port_id, src)
        except Exception as e:
            raise PlatformConnectionException(msg="Cannot turn_off_platform_port: %s" % str(e))

        log.debug("%r: turn_off_platform_port response: %s",
                  self._platform_id, response)

        dic_plat = self._verify_platform_id_in_response(response)
        self._verify_port_id_in_response(port_id, dic_plat)

        return dic_plat  # note: return the dic for the platform

    def set_over_current(self, port_id, ma, us, src=None):
        """
        @param port_id
        @param ma
        @param us
        @param src
                    Some provenance information: actor, mission, etc.
        """
        log.debug("%r: set_over_current: port_id=%s ma=%s us=%s src=%s",
                  self._platform_id, port_id, ma, us, src)

        try:
            response = self._rsn_oms.port.set_over_current(self._platform_id,
                                                           port_id, ma, us, src)
        except Exception as e:
            raise PlatformConnectionException(msg="Cannot set_over_current: %s" % str(e))

        log.debug("%r: set_over_current response: %s",
                  self._platform_id, response)

        dic_plat = self._verify_platform_id_in_response(response)
        self._verify_port_id_in_response(port_id, dic_plat)

        return dic_plat  # note: return the dic for the platform

    ###############################################
    # External event handling:

    def _register_event_listener(self, url):
        """
        Registers given url for all event types.
        """
        log.debug("%r: registering event listener: %s", self._platform_id, url)
        try:
            already_registered = self._rsn_oms.event.get_registered_event_listeners()
        except Exception as e:
            raise PlatformConnectionException(
                msg="%r: Cannot get registered event listeners: %s" % (self._platform_id, e))

        if url in already_registered:
            log.debug("listener %r was already registered", url)
            return

        try:
            result = self._rsn_oms.event.register_event_listener(url)
        except Exception as e:
            raise PlatformConnectionException(
                msg="%r: Cannot register_event_listener: %s" % (self._platform_id, e))

        log.debug("%r: register_event_listener(%r) => %s", self._platform_id, url, result)

    def _unregister_event_listener(self, url):
        """
        Unregisters given url for all event types.
        """
        log.debug("%r: unregistering event listener: %s", self._platform_id, url)
        try:
            result = self._rsn_oms.event.unregister_event_listener(url)
        except Exception as e:
            raise PlatformConnectionException(
                msg="%r: Cannot unregister_event_listener: %s" % (self._platform_id, e))

        log.debug("%r: unregister_event_listener(%r) => %s", self._platform_id, url, result)

    def _start_event_dispatch(self):
        """
        Registers the event listener by using a URL that is composed from
        CFG.server.oms.host, CFG.server.oms.port, and CFG.server.oms.path.

        NOTE: the same listener URL will be registered by multiple RSN platform
        drivers. See other related notes in this file.

        @see https://jira.oceanobservatories.org/tasks/browse/OOIION-1287
        @see https://jira.oceanobservatories.org/tasks/browse/OOIION-968
        """

        # gateway host and port to compose URL:
        host = CFG.get_safe('server.oms.host', "localhost")
        port = CFG.get_safe('server.oms.port', "5000")
        path = CFG.get_safe('server.oms.path', "/ion-service/oms_event")

        self.listener_url = "http://%s:%s%s" % (host, port, path)
        self._register_event_listener(self.listener_url)

        # start OMSDeviceStatusEvent listener to notify the agent about those:
        def event_received(evt, *args, **kwargs):
            log.debug('%r: OmsEventListener received: %s', self._platform_id, evt)
            self._send_event(ExternalEventDriverEvent(evt))

        self._event_listener = self._create_event_subscriber(
            event_type   = 'OMSDeviceStatusEvent',
            origin       = self._platform_id,
            origin_type  = 'OMS Platform',
            callback     = event_received)

        log.debug("%r: started OMSDeviceStatusEvent listener", self._platform_id)

        return "OK"

    def _stop_event_dispatch(self):
        """
        Stops the dispatch of events received from the platform network.

        NOTE: since the same listener URL is registered by multiple RSN
        platform drivers, we avoid unregistering it here because it would
        affect other drivers still depending on the events being notified.

        @see https://jira.oceanobservatories.org/tasks/browse/OOIION-968
        """

        if self._event_listener:
            log.debug("%r: stopping OMSDeviceStatusEvent listener", self._platform_id)
            try:
                self._destroy_event_subscriber(self._event_listener)
            finally:
                self._event_listener = None

        log.debug("%r: Not unregistering listener URL to avoid affecting "
                  "other RSN platform drivers", self._platform_id)

        # unregister listener:
        #self._unregister_event_listener(self.listener_url)
        # NOTE: NO, DON'T unregister: other drivers might still be depending
        # on the listener being registered.

        return "OK"

    ##############################################################
    # GET
    ##############################################################

    def get(self, *args, **kwargs):

        if 'attrs' in kwargs:
            attrs = kwargs['attrs']
            result = self.get_attribute_values(attrs)
            return result

        if 'subplatform_ids' in kwargs:
            result = self.get_subplatform_ids()
            return result

        if 'ports' in kwargs:
            result = self._get_ports()
            return result

        if 'metadata' in kwargs:
            result = self.get_metadata()
            return result

        return super(RSNPlatformDriver, self).get(*args, **kwargs)

    ##############################################################
    # EXECUTE
    ##############################################################

    def execute(self, cmd, *args, **kwargs):
        """
        Executes the given command.

        @param cmd   command

        @return  result of the execution
        """

        if cmd == RSNPlatformDriverEvent.TURN_ON_PORT:
            result = self.turn_on_port(*args, **kwargs)

        elif cmd == RSNPlatformDriverEvent.TURN_OFF_PORT:
            result = self.turn_off_port(*args, **kwargs)

        elif cmd == RSNPlatformDriverEvent.SET_OVER_CURRENT:
            result = self.set_over_current(*args, **kwargs)

        else:
            result = super(RSNPlatformDriver, self).execute(cmd, args, kwargs)

        return result

    def _get_ports(self):

        try:
            response = self._rsn_oms.port.get_platform_ports(self._platform_id)
            ports = response[self._platform_id]

        except Exception as e:
            msg = "Cannot get_platform_ports(platform_id=%r): %s" % (self._platform_id, e)
            raise PlatformConnectionException(msg=msg)

        log.debug("%r: _get_ports: %s", self._platform_id, ports)
        return ports

    ##############################################################
    # CONNECTED event handlers we add in this subclass
    ##############################################################

    def _handler_connected_turn_on_port(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('turn_on_port: missing port_id argument')

        # TODO: provide source info if not explicitly given:
        src = kwargs.get('src', 'source TBD')

        try:
            result = self.turn_on_port(port_id=port_id, src=src)
            return None, result

        except PlatformConnectionException as e:
            return self._connection_lost(RSNPlatformDriverEvent.TURN_ON_PORT,
                                         args, kwargs, e)

    def _handler_connected_turn_off_port(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('turn_off_port: missing port_id argument')

        # TODO: provide source info if not explicitly given:
        src = kwargs.get('src', 'source TBD')

        try:
            result = self.turn_off_port(port_id=port_id, src=src)
            return None, result

        except PlatformConnectionException as e:
            return self._connection_lost(RSNPlatformDriverEvent.TURN_OFF_PORT,
                                         args, kwargs, e)

    def _handler_connected_set_over_current(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('set_over_current: missing port_id argument')
        ma = kwargs.get('ma', None)
        if ma is None:
            raise FSMError('set_over_current: missing ma argument')
        us = kwargs.get('us', None)
        if us is None:
            raise FSMError('set_over_current: missing us argument')

        # TODO: provide source info if not explicitly given:
        src = kwargs.get('src', 'source TBD')

        try:
            result = self.set_over_current(port_id, ma, us, src)
            return None, result

        except PlatformConnectionException as e:
            return self._connection_lost(RSNPlatformDriverEvent.TURN_OFF_PORT,
                                         args, kwargs, e)

    ##############################################################
    # RSN Platform driver FSM setup
    ##############################################################

    def _construct_fsm(self,
                       states=RSNPlatformDriverState,
                       events=RSNPlatformDriverEvent,
                       enter_event=RSNPlatformDriverEvent.ENTER,
                       exit_event=RSNPlatformDriverEvent.EXIT):
        """
        """
        log.debug("constructing RSN platform driver FSM")

        super(RSNPlatformDriver, self)._construct_fsm(states, events,
                                                      enter_event, exit_event)

        # CONNECTED state event handlers we add in this class:
        self._fsm.add_handler(PlatformDriverState.CONNECTED, RSNPlatformDriverEvent.TURN_ON_PORT, self._handler_connected_turn_on_port)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, RSNPlatformDriverEvent.TURN_OFF_PORT, self._handler_connected_turn_off_port)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, RSNPlatformDriverEvent.SET_OVER_CURRENT, self._handler_connected_set_over_current)
